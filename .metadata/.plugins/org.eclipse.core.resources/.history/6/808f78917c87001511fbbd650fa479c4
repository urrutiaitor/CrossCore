/*********************************************************************************

Copyright(c) 2012 Analog Devices, Inc. All Rights Reserved.

This software is proprietary and confidential.  By using this software you agree
to the terms of the associated Analog Devices License Agreement.

*********************************************************************************/
/*!
 * @file      adi_dev_audio_ad1871.c
 * @brief     ADI Device Class Drivers - Audio Class Driver for AD1871 Stereo Audio ADC.
 * @version:  $Revision: 11128 $
 * @date:     $Date: 2012-08-29 04:24:56 -0400 (Wed, 29 Aug 2012) $
 *
 * @details
 *            This is the primary source file for AD1871 Stereo Audio ADC
 *            Audio Class Driver.
 *
 */

/*=============  I N C L U D E S   =============*/

#ifdef _MISRA_RULES
#pragma diag(push)
#pragma diag(suppress:misra_rules_all:"Disable all rules")
#endif

/* AD1871 driver includes */
#include <drivers/adc/ad1871/adi_ad1871.h>
/* Common Device Class Driver API includes */
#include <drivers/device_class/adi_dev_class.h>
/* Audio class API includes */
#include <drivers/device_class/adi_dev_audio_class.h>
/* Physical Device Driver Interface */
#include <drivers/device_class/audio/adi_dev_audio_pdd.h>
/* Device class common includes */
#include <adi_dev_class_common.h>
/* NULL, memset definition includes */
#include <string.h>

#ifdef _MISRA_RULES
#pragma diag(pop)
#endif

/* disable misra diagnostics as necessary */
#ifdef _MISRA_RULES
#pragma diag(push)
#pragma diag(suppress:misra_rule_5_1:"Identifiers (internal and external) may rely on the significance of more than 31 characters.")
#pragma diag(suppress:misra_rule_14_7:"A function may have multiple exit points.")
#endif /* _MISRA_RULES */

/** @addtogroup ADI_AD1871_Class_Driver
 *  @{

    AD1871 Stereo Audio ADC Audio Class driver

The Audio Codec Class Driver provides a common set of APIs to all Audio devices.
An overview of the Audio Class Driver can be found in CCES Help.

The AD1871 Audio Class driver supports ADSP-BF537 and ADSP-BF538 processors, and
uses the respective EZ-KIT Lite configuration as default settings.

- 256 x Fs MCLK (48kHz sample rate)
- 24 bit Word length
- I2S mode for audio data transfer
- Hardware Reset Pins used
    - PF12 for ADSP-BF537 EZ-KIT Lite
    - PD4 for ADSP-BF538 EZ-KIT Lite

Please refer to AD1871 ADC driver documentation for the list of operating modes supported by AD1871 Audio Class driver.

Please refer to Audio Class Driver documentation for the APIs. The documentation is available under
CrossCore Embedded Studio 1.0.1 > System Run-Time Documentation > System Services and Device Drivers > Audio and Video Class Driver API Reference > Modules > Audio Device Class

 */
/*@}*/

/*=============  D E F I N E S  =============*/

/***** Hardware Specific information *****/

/* ADSP-BF534/536/537 */
#if defined(__ADSPBF537_FAMILY__)

/* ADSP-BF537 EZ-Kit Lite as default */

/* SPORT Device number to use */
#define	AD1871_SPORT_DEV_NUM    (0u)

/* GPIO port/pin connected to AD1871 ADC reset pin */
#define	AD1871_RESET_PORT		(ADI_GPIO_PORT_F)
#define	AD1871_RESET_PIN		(ADI_GPIO_PIN_12)

/* ADSP-BF538/539 */
#elif defined(__ADSPBF538_FAMILY__)

/* ADSP-BF538 EZ-Kit Lite as default */

/* SPORT Device number to use */
#define	AD1871_SPORT_DEV_NUM    (0u)

/* GPIO port/pin connected to AD1871 ADC reset pin */
#define	AD1871_RESET_PORT		(ADI_GPIO_PORT_D)
#define	AD1871_RESET_PIN		(ADI_GPIO_PIN_4)

#endif /* __ADSPBF538_FAMILY__ */

/* AD1871 Sampling Rate in Hz (48kHz) */
#define AD1871_SAMPLING_RATE    (48000u)
/* AD1871 Word length in bits (24-bit word length fixed) */
#define AD1871_WLEN_BITS        (24u)
/* AD1871 Word length in bytes (24-bit word length fixed) */
#define AD1871_WLEN_BYTES       (4u)
/* AD1871 active audio channels (stereo device) */
#define AD1871_NUM_IN_CHNLS     (2u)
/* AD1871 SPORT DMA Bus width (use minimum as 16-bit DMA) */
#define AD1871_DMA_WIDTH_BYTES  (2u)
/* AD1871 Number of sub-buffers by default */
#define AD1871_NUM_SUB_BUFFERS  (5u)
/* AD1871 Callback interval in milliseconds */
#define AD1871_CB_INTERVAL      (10u)

/*
 * Data Structures
 */

/* Structure to manage an AD1871 Device class driver instance */
typedef struct  __AdiClassAd1871
{
    uint8_t                     AD1871DevMem[ADI_AD1871_MEMORY_SIZE];   /* Memory required by lower level AD1871 device driver to handle a device */
    ADI_AD1871_HANDLE           hLoLvlAD1871;                           /* Handle to lower level AD1871 device driver instance */
    ADI_CALLBACK                pfCallback;                             /* Callback function supplied by audio class manager */
    void                        *pCBParam;                              /* Client handle passed by audio class manager */
    struct __AdiClassAd1871     *pPrevious;                             /* Pointer to previous device instance in chain */
    struct __AdiClassAd1871     *pNext;                                 /* Pointer to next device instance in chain */
} ADI_CLASS_AD1871;

/*=============  D A T A  =============*/

/* Pointer to AD1871 device class instances that are active */
static ADI_CLASS_AD1871   *pActiveAd1871Dev = NULL;

/*
 *  Local Function Prototypes
 */

/* Open AD1871 Audio Class device */
static uint32_t adi_pdd_Audio_Open (
	uint32_t                        	DeviceNumber,
	ADI_CALLBACK                    	pfCallback,
	void                            	*pCBParam,
	ADI_DEV_AUDIO_PDD_HANDLE        	*phDevice,
	ADI_DEV_AUDIO_MGR_GETPARAMS_FN  	*pfGetParams);

/* Close AD1871 Audio class device */
static uint32_t adi_pdd_Audio_Close (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice);

/* Submit an Audio Rx Buffer */
static uint32_t adi_pdd_Audio_SubmitRxBuffer(
    ADI_DEV_AUDIO_PDD_HANDLE    const   hDevice,
	void                                *pBuffer,
	uint32_t                    const   BufSize);

/* Submit an Audio Tx Buffer */
static uint32_t adi_pdd_Audio_SubmitTxBuffer(
    ADI_DEV_AUDIO_PDD_HANDLE    const   hDevice,
	void                                *pBuffer,
	uint32_t                    const   BufSize);

/* Function clean-up an AD1871 device instance */
static void CleanupInstance (
    ADI_CLASS_AD1871                    *pDevice);

/* Set/Sense Audio device parameters */
static uint32_t adi_pdd_Audio_Control (
    ADI_DEV_AUDIO_PDD_HANDLE        	hDevice,
    uint32_t                        	CommandID,
    void                            	*Value);

/* Set Audio Data Word length */
static uint32_t adi_pdd_Audio_SetWordLength (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID            eChannelID,
    uint32_t                            WordLength);

/* Set Audio Channel Volume */
static uint32_t adi_pdd_Audio_SetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID            eChannelID,
    uint16_t                            rVolume);

/* Get Audio Channel Volume */
static uint32_t adi_pdd_Audio_GetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID            eChannelID,
    uint16_t                            *prVolume);

/* Set Audio Channel Sampling Rate */
static uint32_t adi_pdd_Audio_SetSampleRate (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID            eChannelID,
    uint32_t                            SampleRateHz,
    bool                                bApply);

/* Enable/Disable AD1871 input dataflow */
static uint32_t adi_pdd_AudioIn_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    bool                                bEnable);

/* Enable/Disable AD1871 output dataflow */
static uint32_t adi_pdd_AudioOut_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    bool                                bEnable);

/*
 * Function to be called by Audio Class Manager to get
 * device specific parameters of a physical audio device
 */
static uint32_t  adi_Audio_AD1871_GetDeviceParams(
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_DEVICE_PARAMS         *pDeviceParams);

/* Callback from Lower level driver */
static void AD1871Callback(
    void        						*pCBParam,
    uint32_t    						Event,
    void        						*pArg);

/*=============  D E B U G   F U N C T I O N S =============*/

/* Debug Build only */
#if defined(ADI_DEBUG)

/* Validates AD1871 Audio Class Device Handle */
static uint32_t ValidateHandle (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice);

#endif /* ADI_DEBUG */

/*=============  E N T R Y    P O I N T =============*/

/*
 * AD1871 Audio Class Driver Entry point for Audio Device Manager
 */
ADI_DEV_AUDIO_ENTRY_POINT     ADIDevAudioAD1871EntryPoint =
{
    &adi_pdd_Audio_Open,
    &adi_pdd_Audio_Close,
    &adi_pdd_Audio_SubmitTxBuffer,
    &adi_pdd_Audio_SubmitRxBuffer,
    &adi_pdd_Audio_Control,
    &adi_pdd_AudioIn_EnableDataflow,
    &adi_pdd_AudioOut_EnableDataflow,
    &adi_pdd_Audio_SetWordLength,
    &adi_pdd_Audio_SetVolume,
    &adi_pdd_Audio_GetVolume,
    &adi_pdd_Audio_SetSampleRate
};

/*=============  C O D E  =============*/

/*=============  L O C A L    F U N C T I O N S  =============*/

/*
 * Cleans-up the given AD1871 instance by
 *  - Releasing all memory resources acquired for given device instance
 *  - Deletes all semaphores created for given device instance
 *  - Closes Physical driver handle of the given instance
 *
 * Parameters
 *  - [in]  pDevice     Pointer to AD1871 device instance to work on
 *
 * Return
 *     None
 */
static void CleanupInstance (ADI_CLASS_AD1871    *pDevice)
{
    /* IF (AD1871 low level driver handle is valid) */
    if (pDevice->hLoLvlAD1871 != NULL)
    {
        /* Close the low level AD1871 device */
    	adi_ad1871_Close(pDevice->hLoLvlAD1871);
    }

    /* Destroy this instance */
    _adi_dev_Class_MemFree (pDevice);
}

/*
 * Function called by the Audio class manager to get the
 * physical audio device specific parameters
 *
 * Parameters
 *  - [in]  hDevice         Handle to the Audio device instance to query
 *  - [out] pDeviceParams   Pointer to instance to hold
 *                          audio device specific parameters
 *
 * Return
 *     None
 */
static uint32_t adi_Audio_AD1871_GetDeviceParams(
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_DEVICE_PARAMS     *pDeviceParams)
{
    /* Pointer to AD1871 device instance to work on */
    ADI_CLASS_AD1871   *pDevice = (ADI_CLASS_AD1871 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1871 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* Audio input parameters for AD1871 */
    pDeviceParams->hInPort                  = pDevice->hLoLvlAD1871;
    pDeviceParams->nInSampleRate            = AD1871_SAMPLING_RATE;
    pDeviceParams->nInDmaBusWidth           = AD1871_DMA_WIDTH_BYTES;
    pDeviceParams->nMinInSubBuffers         = AD1871_NUM_SUB_BUFFERS;
    pDeviceParams->nInCallbackInterval      = AD1871_CB_INTERVAL;
    pDeviceParams->nInWordLengthInBytes     = AD1871_WLEN_BYTES;
    pDeviceParams->nNumActiveInChannels     = AD1871_NUM_IN_CHNLS;

    /* Audio output parameters for AD1871 is not valid as this is an ADC device */
    pDeviceParams->hOutPort                 = NULL;
    pDeviceParams->nOutSampleRate           = 0u;
    pDeviceParams->nOutDmaBusWidth          = 0u;
    pDeviceParams->nMinOutSubBuffers        = 0u;
    pDeviceParams->nOutCallbackInterval     = AD1871_CB_INTERVAL;
    pDeviceParams->nOutWordLengthInBytes    = 0u;
    pDeviceParams->nNumActiveOutChannels    = 0u;

    return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
}

/*=============  C A L L B A C K   F U N C T I O N S =============*/

/*
 * Callback from Lower level driver
 *
 * Parameters
 *  - pCBParam      AD1871 instance to which the callback belongs.
 *  - Event         Callback Event ID
 *  - pArg          Event specific argument
 *
 * Return
 *  None
 *
 */
static void AD1871Callback(
    void        *pCBParam,
    uint32_t    Event,
    void        *pArg)
{
    /* AD1871 device instance to which the callback belongs */
	ADI_CLASS_AD1871 *pDevice = (ADI_CLASS_AD1871 *)pCBParam;

	/* IF (Buffer processed event) */
    if (Event == (uint32_t)ADI_AD1871_EVENT_BUFFER_PROCESSED)
    {
        /* Post callback to audio class manager */
        (pDevice->pfCallback)(pDevice->pCBParam, (uint32_t) ADI_DEV_CLASS_EVENT_RX_BUFFER_PROCESSED, pArg);
    }
}

/*=============  D E B U G   F U N C T I O N S =============*/

/* Debug build only */
#if defined(ADI_DEBUG)

/*
 * Validates AD1871 Audio Class Device Handle
 *
 * Parameters:
 *  - [in]  hDevice     AD1871 Audio Class Device handle to validate
 *
 * Return:
 *     - #ADI_DEV_AUDIO_RESULT_NOERROR: Supplied device handle is valid.
 *     - #ADI_DEV_AUDIO_RESULT_HANDLE_INVALID: Supplied device handle is invalid.
 *
 */
static uint32_t ValidateHandle (
    ADI_DEV_AUDIO_PDD_HANDLE      hDevice)
{
    /* Pointer to AD1871 device instance to validate */
    ADI_CLASS_AD1871    *pValidateDevice = (ADI_CLASS_AD1871 *)hDevice;
    /* Pointer to an AD1871 device class instance from the active driver instance list */
    ADI_CLASS_AD1871    *pActiveDevice;

    /* Compare the given Handle with Audio Class Device Handles that are active */
    for (pActiveDevice = pActiveAd1871Dev;
         pActiveDevice != NULL;
         pActiveDevice = pActiveDevice->pNext)
    {
        /* IF (Given handle is available in active driver list) */
        if (pValidateDevice == pActiveDevice)
        {
            /* Given Audio Class Device Handle is valid, return success */
            return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
        }
    }

    /* End of active device list, handle invalid - return error */
    return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
}

#endif /* ADI_DEBUG */

/*=============  D R I V E R   C L A S S   F U N C T I O N S =============*/

/*
 *     Opens an AD1871 Audio Class device for use
 *
 * Parameters:
 *  - [in]  DeviceNumber    Physical Device number to open
 *  - [in]  pfCallback      Pointer to application callback function
 *  - [in]  pCBParam        Client handle to be passed to audio class manager callback function
 *  - [out] phDevice        Pointer to location to store handle to Audio Class Device
 *  - [out] pfGetParams     Pointer to location to store address of function to be called by
 *                          audio class manager to get device specific parameters of a
 *                          physical audio device
 *
 * Return:
 *     TBD
 */
static uint32_t adi_pdd_Audio_Open (
	    uint32_t                        DeviceNumber,
	    ADI_CALLBACK                    pfCallback,
	    void                            *pCBParam,
	    ADI_DEV_AUDIO_PDD_HANDLE        *phDevice,
	    ADI_DEV_AUDIO_MGR_GETPARAMS_FN  *pfGetParams)
{
    /* Return codes */
	uint32_t            Result;
	ADI_AD1871_RESULT   eResult;
	/* Handle to lower level AD1871 device instance */
	ADI_AD1871_HANDLE   hAD1871;
    /* Pointer to AD1871 audio class driver instance to work on */
    ADI_CLASS_AD1871    *pDevice = NULL;
    /* Pointer to Last AD1871 audio class driver instance in active list */
    ADI_CLASS_AD1871    *poLastDevice = NULL;

    /* Allocate memory to handle an AD1871 device instance */
    Result = (uint32_t) _adi_dev_Class_MemAlloc (sizeof (ADI_CLASS_AD1871), (void *)&pDevice);

    /* IF (Error) */
    if (Result != (uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS)
	{
	    /* Return error */
	    return (Result);
	}

    /* Clear the allocated memory */
    memset(pDevice, 0, sizeof (ADI_CLASS_AD1871));

    /* Open low level AD1871 driver */
	eResult = adi_ad1871_Open (DeviceNumber,
	                           &(pDevice->AD1871DevMem),
	                           ADI_AD1871_MEMORY_SIZE,
	                           &pDevice->hLoLvlAD1871);

    /* IF (Error) */
    if (eResult != ADI_AD1871_SUCCESS)
    {
        /* Return error */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_DEV_OPEN_FAILED);
    }

    /* Register callback with lower level driver */
    eResult = adi_ad1871_SetCallback(pDevice->hLoLvlAD1871, AD1871Callback, pDevice);

    /* IF (Success) */
    if (eResult == ADI_AD1871_SUCCESS)
    {
        /* Set default SPORT device with AD1871 as clock master */
        eResult = adi_ad1871_SetSportDevice (pDevice->hLoLvlAD1871, AD1871_SPORT_DEV_NUM, true);
    }

    /* IF (Error) */
    if (eResult != ADI_AD1871_SUCCESS)
    {
        /* Clean up and release all memory resources acquired for
           this AD1871 device instance */
        CleanupInstance(pDevice);
        /* Return error */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_DEV_OPEN_FAILED);
    }

    /* Save callback information */
    pDevice->pfCallback	= pfCallback;
    pDevice->pCBParam 	= pCBParam;

    /* Save address of function to be called by Audio class manager
       to get device specific parameters of a physical audio device */
    *pfGetParams = &adi_Audio_AD1871_GetDeviceParams;

    /*
    ** Add this instance to Active AD1871 driver instances list
    */

    /* Entering critical code segment
       Protect this code segment from interrupts */
    adi_osal_EnterCriticalRegion ();

    /* Add this instance to AD1871 active device chain */
    pDevice->pPrevious = pActiveAd1871Dev;

    /* IF (This is not the first instance to be opened) */
    if (pActiveAd1871Dev != NULL)
    {
        /* Chain this device to the last instance in chain */
        pActiveAd1871Dev->pNext = pDevice;
    }
    /* Make this device as last instance in chain */
    pActiveAd1871Dev = pDevice;

    /* Re-enable interrupts */
    adi_osal_ExitCriticalRegion();

    /* Pass the Audio class device handle to Audio Device Manager */
    *phDevice = (ADI_DEV_AUDIO_PDD_HANDLE *) pDevice;

    return (Result);
}

/*
 * Closes an AD1871 audio class device
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to close
 *
 * Return:
 *  TBD
 */
static uint32_t adi_pdd_Audio_Close (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice)
{
    /* Pointer to AD1871 audio class driver instance to close */
    ADI_CLASS_AD1871   *pDevice = (ADI_CLASS_AD1871 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1871 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* Clean up and release all memory resources acquired for
       this AD1871 device instance */
    CleanupInstance(pDevice);

    /*-- Remove this device from AD1871 device in use chain --*/

    /* Protect this section of code - entering a critical region    */
    adi_osal_EnterCriticalRegion();

    /* IF (This is the last device instance in chain) */
    if (pActiveAd1871Dev == pDevice)
    {
        /* Make the previous instance linked to this device as last in chain */
        pActiveAd1871Dev = pDevice->pPrevious;
    }

    /* IF (This is not the first device in chain) */
    if (pDevice->pPrevious != NULL)
    {
        /* Remove this instance from the chain */
        pDevice->pPrevious->pNext = pDevice->pNext;
    }
    /* ELSE (This is the first device in chain) */
    else
    {
        /* IF (we've more than one device in chain) */
        if (pDevice->pNext != NULL)
        {
            /* Remove this instance from the chain */
            pDevice->pNext->pPrevious = NULL;
        }
    }

    /* Exit the critical region */
    adi_osal_ExitCriticalRegion();

    return((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
}

/*
 * Submit a TX Buffer
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on
 *  - [in]  pBuffer     Pointer to audio buffer with valid data.
 *  - [in]  BufSize     Audio buffer size in bytes.
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 *
 */
static uint32_t adi_pdd_Audio_SubmitTxBuffer(
		ADI_DEV_AUDIO_PDD_HANDLE const  hDevice,
		void                            *pBuffer,
		uint32_t                 const  BufSize)
{
    /* AD1871 can only receive audio */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Submit a RX Buffer
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on
 *  - [in]  pBuffer     Pointer to audio buffer to fill.
 *  - [in]  BufSize     Audio buffer size in bytes.
 *
 * Return:
 *  TBD
 *
 */
static uint32_t adi_pdd_Audio_SubmitRxBuffer(
		ADI_DEV_AUDIO_PDD_HANDLE const  hDevice,
		void                            *pBuffer,
		uint32_t                 const  BufSize)
{
    /* Device instance to work on */
	ADI_CLASS_AD1871   *pDevice = (ADI_CLASS_AD1871 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1871 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* IF (Failed to submit Audio Rx buffer) */
    if (adi_ad1871_SubmitRxBuffer(pDevice->hLoLvlAD1871, pBuffer, BufSize) != ADI_AD1871_SUCCESS)
    {
        /* Return error */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_FAILED);
    }
    /* ELSE (Successfully submitted Audio Rx buffer) */
    else
    {
        /* Return success */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS);
    }
}

/*
 * Set/Sense Audio device parameters
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  CommandID       Command ID to process
 *  - [in]  Value           Command specific value
 *
 * Return:
 *  TBD
 */
static uint32_t adi_pdd_Audio_Control (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    uint32_t                        CommandID,
    void                            *Value)
{
    /* Return codes */
	uint32_t            Result = (uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS;
	ADI_AD1871_RESULT   eResult = ADI_AD1871_SUCCESS;
    /* Pointer to AD1871 audio class driver instance to work on */
    ADI_CLASS_AD1871   *pDevice = (ADI_CLASS_AD1871 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1871 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* IF (Reset Audio Device) */
    if (CommandID == (uint32_t) ADI_DEV_AUDIO_CMD_RESET)
    {
        /* Issue a hardware reset */
        eResult = adi_ad1871_HwReset (pDevice->hLoLvlAD1871, AD1871_RESET_PORT, AD1871_RESET_PIN);
    }
    /* ELSE IF (Set Audio Input Port Device number) */
    else if (CommandID == (uint32_t) ADI_DEV_AUDIO_CMD_SET_IN_PORT_DEVICE_NUMBER)
    {
        /* Set default SPORT device with AD1871 as clock master */
        eResult = adi_ad1871_SetSportDevice (pDevice->hLoLvlAD1871, (uint32_t) Value, true);
    }
    /* ELSE IF (Enable/Disable Audio Input Data Port) */
    else if (CommandID == (uint32_t) ADI_DEV_AUDIO_CMD_ENABLE_IN_PORT)
    {
        Result = (uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS;
    }
    /* ELSE (Other commands) */
    else
    {
        /* Function not supported */
        Result = (uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED;
    }

    /* IF (Lower level driver returns error) */
    if (eResult != ADI_AD1871_SUCCESS)
    {
        Result = (uint32_t) ADI_DEV_CLASS_RESULT_FAILED;
    }

    return(Result);
}

/*
 * Enable/Disable audio input (Rx) dataflow
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on
 *
 * Return:
 *  TBD
 */
static uint32_t adi_pdd_AudioIn_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    bool                            bEnable)
{
	ADI_CLASS_AD1871   *pDevice = (ADI_CLASS_AD1871 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1871 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* IF (Failed to enable/disable audio dataflow) */
    if (adi_ad1871_Enable(pDevice->hLoLvlAD1871, bEnable) != ADI_AD1871_SUCCESS)
    {
        /* Return error */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_FAILED);
    }
    /* ELSE (Successfully enabled/disabled audio dataflow) */
    else
    {
        /* Return success */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS);
    }
}

/*
 * Enable/Disable audio output (Tx) dataflow
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 *
 */
static uint32_t adi_pdd_AudioOut_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    bool                            bEnable)
{
	/* AD1871 can only receive audio */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Sets Audio Data Word length
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to which the word length applies
 *  - [in]  WordLength      Audio data word length to set
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_NOERROR: Successfully configured Word Length
 *      - ADI_DEV_AUDIO_RESULT_WORD_LENGTH_INVALID: Word Length not supported
 *
 */
static uint32_t adi_pdd_Audio_SetWordLength (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint32_t                        WordLength)
{
    /* IF (Word Length is other than 24-bits) */
    if (WordLength != AD1871_WLEN_BITS)
    {
        /* Return error as word length not supported */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_WORD_LENGTH_INVALID);
    }
    /* ELSE (Word Length supported) */
    else
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
    }
}

/*
 * Sets Audio Channel volume
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to set volume
 *  - [in]  rVolume         Channel Volume range in linear steps
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 *
 */
static uint32_t adi_pdd_Audio_SetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint16_t                        rVolume)
{
    /* AD1871 operating mode is established by external hardware control,
       hence the device registers can't be accessed */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Gets Audio Channel volume
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to set volume
 *  - [in]  prVolume        Location to store Channel Volume
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 *
 */
static uint32_t adi_pdd_Audio_GetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint16_t                        *prVolume)
{
    /* AD1871 operating mode is established by external hardware control,
       hence the device registers can't be accessed */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Sets Audio Sample rate of selected channel
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to set volume
 *  - [in]  SampleRateHz    Sample rate in Hertz
 *  - [in]  bApply          'true' to apply the sample rate to selected channel
                            'false' to cache the sample rate with in the driver
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_NOERROR: Successfully configured sample rate
 *      - ADI_DEV_AUDIO_RESULT_SAMPLE_RATE_INVALID: Sample Rate not supported
 *
 */
static uint32_t adi_pdd_Audio_SetSampleRate (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint32_t                        SampleRateHz,
    bool                            bApply)
{
    /* IF (Sample Rate is other than 48kHz) */
    if (SampleRateHz != AD1871_SAMPLING_RATE)
    {
        /* Return error as sample rate not supported */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_SAMPLE_RATE_INVALID);
    }
    /* ELSE (Sample Rate supported) */
    else
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
    }
}

#ifdef _MISRA_RULES
#pragma diag(pop)
#endif /* _MISRA_RULES */

/*****/
