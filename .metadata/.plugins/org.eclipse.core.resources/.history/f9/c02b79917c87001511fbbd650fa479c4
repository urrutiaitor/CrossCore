/*********************************************************************************

Copyright(c) 2012 Analog Devices, Inc. All Rights Reserved.

This software is proprietary and confidential.  By using this software you agree
to the terms of the associated Analog Devices License Agreement.

*********************************************************************************/
/*!
 * @file      adi_dev_audio_ad1854.c
 * @brief     ADI Device Class Drivers - Audio Class Driver for AD1854 Stereo Audio DAC.
 * @version:  $Revision: 11128 $
 * @date:     $Date: 2012-08-29 04:24:56 -0400 (Wed, 29 Aug 2012) $
 *
 * @details
 *            This is the primary source file for AD1854 Stereo Audio DAC
 *            Audio Class Driver.
 *
 */

/*=============  I N C L U D E S   =============*/

#ifdef _MISRA_RULES
#pragma diag(push)
#pragma diag(suppress:misra_rules_all:"Disable all rules")
#endif

/* AD1854 driver includes */
#include <drivers/dac/ad1854/adi_ad1854.h>
/* Common Device Class Driver API includes */
#include <drivers/device_class/adi_dev_class.h>
/* Audio class API includes */
#include <drivers/device_class/adi_dev_audio_class.h>
/* Physical Device Driver Interface */
#include <drivers/device_class/audio/adi_dev_audio_pdd.h>
/* Device class common includes */
#include <adi_dev_class_common.h>
/* NULL, memset definition includes */
#include <string.h>

#ifdef _MISRA_RULES
#pragma diag(pop)
#endif

/* disable misra diagnostics as necessary */
#ifdef _MISRA_RULES
#pragma diag(push)
#pragma diag(suppress:misra_rule_5_1:"Identifiers (internal and external) may rely on the significance of more than 31 characters.")
#pragma diag(suppress:misra_rule_14_7:"A function may have multiple exit points.")
#endif /* _MISRA_RULES */

/** @addtogroup ADI_AD1854_Class_Driver
 *  @{

    AD1854 Stereo Audio DAC Audio Class driver

The Audio Codec Class Driver provides a common set of APIs to all Audio devices.
An overview of the Audio Class Driver can be found in CCES Help.

The AD1854 Audio Class driver supports ADSP-BF537 and ADSP-BF538 processors, and
uses the respective EZ-KIT Lite configuration as default settings.

- 256 x Fs MCLK (48kHz sample rate)
- 24 bit Word length
- I2S mode for audio data transfer
- Hardware Reset Pins used
    - PF12 for ADSP-BF537 EZ-KIT Lite
    - PD4 for ADSP-BF538 EZ-KIT Lite

Please refer to AD1854 DAC driver documentation for the list of operating modes supported by AD1854 Audio Class driver.

Please refer to Audio Class Driver documentation for the APIs. The documentation is available under
CrossCore Embedded Studio 1.0.1 > System Run-Time Documentation > System Services and Device Drivers > Audio and Video Class Driver API Reference > Modules > Audio Device Class

 */
/*@}*/

/*=============  D E F I N E S  =============*/

/***** Hardware Specific information *****/

/* ADSP-BF534/536/537 */
#if defined(__ADSPBF537_FAMILY__)

/* ADSP-BF537 EZ-Kit Lite as default */

/* SPORT Device number to use */
#define	AD1854_SPORT_DEV_NUM    (0u)

/* GPIO port/pin connected to AD1854 DAC reset pin */
#define	AD1854_RESET_PORT		(ADI_GPIO_PORT_F)
#define	AD1854_RESET_PIN		(ADI_GPIO_PIN_12)

/* ADSP-BF538/539 */
#elif defined(__ADSPBF538_FAMILY__)

/* ADSP-BF538 EZ-Kit Lite as default */

/* SPORT Device number to use */
#define	AD1854_SPORT_DEV_NUM    (0u)

/* GPIO port/pin connected to AD1854 DAC reset pin */
#define	AD1854_RESET_PORT		(ADI_GPIO_PORT_D)
#define	AD1854_RESET_PIN		(ADI_GPIO_PIN_4)

#endif /* __ADSPBF538_FAMILY__ */

/* AD1854 Sampling Rate in Hz (48kHz) */
#define AD1854_SAMPLING_RATE    (48000u)
/* AD1854 Word length in bits (24-bit word length fixed) */
#define AD1854_WLEN_BITS        (24u)
/* AD1854 Word length in bytes (24-bit word length fixed) */
#define AD1854_WLEN_BYTES       (4u)
/* AD1854 active audio channels (stereo device) */
#define AD1854_NUM_OUT_CHNLS    (2u)
/* AD1854 SPORT DMA Bus width (use minimum as 16-bit DMA) */
#define AD1854_DMA_WIDTH_BYTES  (2u)
/* AD1854 Number of sub-buffers by default */
#define AD1854_NUM_SUB_BUFFERS  (5u)
/* AD1854 Callback interval in milliseconds */
#define AD1854_CB_INTERVAL      (10u)

/*
 * Data Structures
 */

/* Structure to manage an AD1854 Device class driver instance */
typedef struct  __AdiClassAd1854
{
    uint8_t                     AD1854DevMem[ADI_AD1854_MEMORY_SIZE];   /* Memory required by lower level AD1854 device driver to handle a device */
    ADI_AD1854_HANDLE           hLoLvlAD1854;                           /* Handle to lower level AD1854 device driver instance */
    ADI_CALLBACK                pfCallback;                             /* Callback function supplied by audio class manager */
    void                        *pCBParam;                              /* Client handle passed by audio class manager */
    struct __AdiClassAd1854     *pPrevious;                             /* Pointer to previous device instance in chain */
    struct __AdiClassAd1854     *pNext;                                 /* Pointer to next device instance in chain */
} ADI_CLASS_AD1854;

/*=============  D A T A  =============*/

/* Pointer to AD1854 device class instances that are active */
static ADI_CLASS_AD1854   *pActiveAd1854Dev = NULL;

/*
 *  Local Function Prototypes
 */

/* Open AD1854 Audio Class device */
static uint32_t adi_pdd_Audio_Open (
	uint32_t                        	DeviceNumber,
	ADI_CALLBACK                    	pfCallback,
	void                            	*pCBParam,
	ADI_DEV_AUDIO_PDD_HANDLE        	*phDevice,
	ADI_DEV_AUDIO_MGR_GETPARAMS_FN  	*pfGetParams);

/* Close AD1854 Audio class device */
static uint32_t adi_pdd_Audio_Close (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice);

/* Submit an Audio Rx Buffer */
static uint32_t adi_pdd_Audio_SubmitRxBuffer(
    ADI_DEV_AUDIO_PDD_HANDLE    const   hDevice,
	void                                *pBuffer,
	uint32_t                    const   BufSize);

/* Submit an Audio Tx Buffer */
static uint32_t adi_pdd_Audio_SubmitTxBuffer(
    ADI_DEV_AUDIO_PDD_HANDLE    const   hDevice,
	void                                *pBuffer,
	uint32_t                    const   BufSize);

/* Function clean-up an AD1854 device instance */
static void CleanupInstance (
    ADI_CLASS_AD1854                    *pDevice);

/* Set/Sense Audio device parameters */
static uint32_t adi_pdd_Audio_Control (
    ADI_DEV_AUDIO_PDD_HANDLE        	hDevice,
    uint32_t                        	CommandID,
    void                            	*Value);

/* Set Audio Data Word length */
static uint32_t adi_pdd_Audio_SetWordLength (
    ADI_DEV_AUDIO_PDD_HANDLE        	hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        	eChannelID,
    uint32_t                        	WordLength);

/* Set Audio Channel Volume */
static uint32_t adi_pdd_Audio_SetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID            eChannelID,
    uint16_t                            rVolume);

/* Get Audio Channel Volume */
static uint32_t adi_pdd_Audio_GetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID            eChannelID,
    uint16_t                            *prVolume);

/* Set Audio Channel Sampling Rate */
static uint32_t adi_pdd_Audio_SetSampleRate (
    ADI_DEV_AUDIO_PDD_HANDLE        	hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        	eChannelID,
    uint32_t                        	SampleRateHz,
    bool                            	bApply);

/* Enable/Disable AD1854 input dataflow */
static uint32_t adi_pdd_AudioIn_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    bool                                bEnable);

/* Enable/Disable AD1854 output dataflow */
static uint32_t adi_pdd_AudioOut_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    bool                                bEnable);

/*
 * Function to be called by Audio Class Manager to get
 * device specific parameters of a physical audio device
 */
static uint32_t  adi_Audio_AD1854_GetDeviceParams(
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice,
    ADI_DEV_AUDIO_DEVICE_PARAMS         *pDeviceParams);

/* Callback from Lower level driver */
static void AD1854Callback(
    void        						*pCBParam,
    uint32_t    						Event,
    void        						*pArg);

/*=============  D E B U G   F U N C T I O N S =============*/

/* Debug Build only */
#if defined(ADI_DEBUG)

/* Validates AD1854 Audio Class Device Handle */
static uint32_t ValidateHandle (
    ADI_DEV_AUDIO_PDD_HANDLE            hDevice);

#endif /* ADI_DEBUG */

/*=============  E N T R Y    P O I N T =============*/

/* AD1854 Audio Class Driver Entry point for Audio Device Manager */
ADI_DEV_AUDIO_ENTRY_POINT     ADIDevAudioAD1854EntryPoint =
{
    &adi_pdd_Audio_Open,
    &adi_pdd_Audio_Close,
    &adi_pdd_Audio_SubmitTxBuffer,
    &adi_pdd_Audio_SubmitRxBuffer,
    &adi_pdd_Audio_Control,
    &adi_pdd_AudioIn_EnableDataflow,
    &adi_pdd_AudioOut_EnableDataflow,
    &adi_pdd_Audio_SetWordLength,
    &adi_pdd_Audio_SetVolume,
    &adi_pdd_Audio_GetVolume,
    &adi_pdd_Audio_SetSampleRate
};

/*=============  C O D E  =============*/

/*=============  L O C A L    F U N C T I O N S  =============*/

/*
 * Cleans-up the given AD1854 instance by
 *  - Releasing all memory resources acquired for given device instance
 *  - Deletes all semaphores created for given device instance
 *  - Closes Physical driver handle of the given instance
 *
 * Parameters
 *  - [in]  pDevice     Pointer to AD1854 device instance to work on
 *
 * Return
 *     None
 */
static void CleanupInstance (ADI_CLASS_AD1854    *pDevice)
{
    /* IF (AD1854 low level driver handle is valid) */
    if (pDevice->hLoLvlAD1854 != NULL)
    {
        /* Close the low level AD1854 device */
    	adi_ad1854_Close(pDevice->hLoLvlAD1854);
    }

    /* Destroy this instance */
    _adi_dev_Class_MemFree (pDevice);
}

/*
 * Function called by the Audio class manager to get the
 * physical audio device specific parameters
 *
 * Parameters
 *  - [in]  hDevice         Handle to the Audio device instance to query
 *  - [out] pDeviceParams   Pointer to instance to hold
 *                          audio device specific parameters
 *
 * Return
 *     None
 */
static uint32_t adi_Audio_AD1854_GetDeviceParams(
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_DEVICE_PARAMS     *pDeviceParams)
{
    /* Pointer to AD1854 device instance to work on */
    ADI_CLASS_AD1854   *pDevice = (ADI_CLASS_AD1854 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1854 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* Audio input parameters for AD1854 is not valid as this is a DAC device */
    pDeviceParams->hInPort                  = NULL;
    pDeviceParams->nInSampleRate            = 0u;
    pDeviceParams->nInDmaBusWidth           = 0u;
    pDeviceParams->nMinInSubBuffers         = 0u;
    pDeviceParams->nInCallbackInterval      = AD1854_CB_INTERVAL;
    pDeviceParams->nInWordLengthInBytes     = 0u;
    pDeviceParams->nNumActiveInChannels     = 0u;

    /* Audio output parameters for AD1854 */
    pDeviceParams->hOutPort                 = pDevice->hLoLvlAD1854;
    pDeviceParams->nOutSampleRate           = AD1854_SAMPLING_RATE;
    pDeviceParams->nOutDmaBusWidth          = AD1854_DMA_WIDTH_BYTES;
    pDeviceParams->nMinOutSubBuffers        = AD1854_NUM_SUB_BUFFERS;
    pDeviceParams->nOutCallbackInterval     = AD1854_CB_INTERVAL;
    pDeviceParams->nOutWordLengthInBytes    = AD1854_WLEN_BYTES;
    pDeviceParams->nNumActiveOutChannels    = AD1854_NUM_OUT_CHNLS;

    return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
}

/*=============  C A L L B A C K   F U N C T I O N S =============*/

/*
 * Callback from Lower level driver
 *
 * Parameters
 *  - pCBParam      AD1854 instance to which the callback belongs.
 *  - Event         Callback Event ID
 *  - pArg          Event specific argument
 *
 * Return
 *  None
 *
 */
static void AD1854Callback(
    void        *pCBParam,
    uint32_t    Event,
    void        *pArg)
{
    /* AD1854 device instance to which the callback belongs */
	ADI_CLASS_AD1854 *pDevice = (ADI_CLASS_AD1854 *)pCBParam;

	/* IF (Buffer processed event) */
    if (Event == (uint32_t)ADI_AD1854_EVENT_BUFFER_PROCESSED)
    {
        /* Post callback to audio class manager */
        (pDevice->pfCallback)(pDevice->pCBParam, (uint32_t) ADI_DEV_CLASS_EVENT_TX_BUFFER_PROCESSED, pArg);
    }
}

/*=============  D E B U G   F U N C T I O N S =============*/

/* Debug build only */
#if defined(ADI_DEBUG)

/*
 * Validates AD1854 Audio Class Device Handle
 *
 * Parameters:
 *  - [in]  hDevice     AD1854 Audio Class Device handle to validate
 *
 * Return:
 *     - #ADI_DEV_AUDIO_RESULT_NOERROR: Supplied device handle is valid.
 *     - #ADI_DEV_AUDIO_RESULT_HANDLE_INVALID: Supplied device handle is invalid.
 *
 */
static uint32_t ValidateHandle (
    ADI_DEV_AUDIO_PDD_HANDLE      hDevice)
{
    /* Pointer to AD1854 device instance to validate */
    ADI_CLASS_AD1854    *pValidateDevice = (ADI_CLASS_AD1854 *)hDevice;
    /* Pointer to an AD1854 device class instance from the active driver instance list */
    ADI_CLASS_AD1854    *pActiveDevice;

    /* Compare the given Handle with Audio Class Device Handles that are active */
    for (pActiveDevice = pActiveAd1854Dev;
         pActiveDevice != NULL;
         pActiveDevice = pActiveDevice->pNext)
    {
        /* IF (Given handle is available in active driver list) */
        if (pValidateDevice == pActiveDevice)
        {
            /* Given Audio Class Device Handle is valid, return success */
            return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
        }
    }

    /* End of active device list, handle invalid - return error */
    return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
}

#endif /* ADI_DEBUG */

/*=============  D R I V E R   C L A S S   F U N C T I O N S =============*/

/*
 *     Opens an AD1854 Audio Class device for use
 *
 * Parameters:
 *  - [in]  DeviceNumber    Physical Device number to open
 *  - [in]  pfCallback      Pointer to application callback function
 *  - [in]  pCBParam        Client handle to be passed to audio class manager callback function
 *  - [out] phDevice        Pointer to location to store handle to Audio Class Device
 *  - [out] pfGetParams     Pointer to location to store address of function to be called by
 *                          audio class manager to get device specific parameters of a
 *                          physical audio device
 *
 * Return:
 *     TBD
 */
static uint32_t adi_pdd_Audio_Open (
	    uint32_t                        DeviceNumber,
	    ADI_CALLBACK                    pfCallback,
	    void                            *pCBParam,
	    ADI_DEV_AUDIO_PDD_HANDLE        *phDevice,
	    ADI_DEV_AUDIO_MGR_GETPARAMS_FN  *pfGetParams)
{
    /* Return codes */
	uint32_t            Result;
	ADI_AD1854_RESULT   eResult;
	/* Handle to lower level AD1854 device instance */
	ADI_AD1854_HANDLE   hAD1854;
    /* Pointer to AD1854 audio class driver instance to work on */
    ADI_CLASS_AD1854    *pDevice = NULL;
    /* Pointer to Last AD1854 audio class driver instance in active list */
    ADI_CLASS_AD1854    *poLastDevice = NULL;

    /* Allocate memory to handle an AD1854 device instance */
    Result = (uint32_t) _adi_dev_Class_MemAlloc (sizeof (ADI_CLASS_AD1854), (void *)&pDevice);

    /* IF (Error) */
    if (Result != (uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS)
	{
	    /* Return error */
	    return (Result);
	}

    /* Clear the allocated memory */
    memset(pDevice, 0, sizeof (ADI_CLASS_AD1854));

    /* Open low level AD1854 driver */
	eResult = adi_ad1854_Open (DeviceNumber,
	                           &(pDevice->AD1854DevMem),
	                           ADI_AD1854_MEMORY_SIZE,
	                           &pDevice->hLoLvlAD1854);

    /* IF (Error) */
    if (eResult != ADI_AD1854_SUCCESS)
    {
        /* Return error */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_DEV_OPEN_FAILED);
    }

    /* Register callback with lower level driver */
    eResult = adi_ad1854_SetCallback(pDevice->hLoLvlAD1854, AD1854Callback, pDevice);

    /* IF (Success) */
    if (eResult == ADI_AD1854_SUCCESS)
    {
        /* Set default SPORT device with AD1854 as clock master */
        eResult = adi_ad1854_SetSportDevice (pDevice->hLoLvlAD1854, AD1854_SPORT_DEV_NUM, true);
    }

    /* IF (Error) */
    if (eResult != ADI_AD1854_SUCCESS)
    {
        /* Clean up and release all memory resources acquired for
           this AD1854 device instance */
        CleanupInstance(pDevice);
        /* Return error */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_DEV_OPEN_FAILED);
    }

    /* Save callback information */
    pDevice->pfCallback	= pfCallback;
    pDevice->pCBParam 	= pCBParam;

    /* Save address of function to be called by Audio class manager
       to get device specific parameters of a physical audio device */
    *pfGetParams = &adi_Audio_AD1854_GetDeviceParams;

    /*
    ** Add this instance to Active AD1854 driver instances list
    */

    /* Entering critical code segment
       Protect this code segment from interrupts */
    adi_osal_EnterCriticalRegion ();

    /* Add this instance to AD1854 active device chain */
    pDevice->pPrevious = pActiveAd1854Dev;

    /* IF (This is not the first instance to be opened) */
    if (pActiveAd1854Dev != NULL)
    {
        /* Chain this device to the last instance in chain */
        pActiveAd1854Dev->pNext = pDevice;
    }
    /* Make this device as last instance in chain */
    pActiveAd1854Dev = pDevice;

    /* Re-enable interrupts */
    adi_osal_ExitCriticalRegion();

    /* Pass the Audio class device handle to Audio Device Manager */
    *phDevice = (ADI_DEV_AUDIO_PDD_HANDLE *) pDevice;

    return (Result);
}

/*
 * Closes an AD1854 audio class device
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to close
 *
 * Return:
 *  TBD
 */
static uint32_t adi_pdd_Audio_Close (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice)
{
    /* Pointer to AD1854 audio class driver instance to close */
    ADI_CLASS_AD1854   *pDevice = (ADI_CLASS_AD1854 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1854 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* Clean up and release all memory resources acquired for
       this AD1854 device instance */
    CleanupInstance(pDevice);

    /*-- Remove this device from AD1854 device in use chain --*/

    /* Protect this section of code - entering a critical region    */
    adi_osal_EnterCriticalRegion();

    /* IF (This is the last device instance in chain) */
    if (pActiveAd1854Dev == pDevice)
    {
        /* Make the previous instance linked to this device as last in chain */
        pActiveAd1854Dev = pDevice->pPrevious;
    }

    /* IF (This is not the first device in chain) */
    if (pDevice->pPrevious != NULL)
    {
        /* Remove this instance from the chain */
        pDevice->pPrevious->pNext = pDevice->pNext;
    }
    /* ELSE (This is the first device in chain) */
    else
    {
        /* IF (we've more than one device in chain) */
        if (pDevice->pNext != NULL)
        {
            /* Remove this instance from the chain */
            pDevice->pNext->pPrevious = NULL;
        }
    }

    /* Exit the critical region */
    adi_osal_ExitCriticalRegion();

    return((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
}

/*
 * Submit a TX Buffer
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on
 *  - [in]  pBuffer     Pointer to audio buffer with valid data.
 *  - [in]  BufSize     Audio buffer size in bytes.
 *
 * Return:
 *      TBD
 *
 */
static uint32_t adi_pdd_Audio_SubmitTxBuffer(
		ADI_DEV_AUDIO_PDD_HANDLE const  hDevice,
		void                            *pBuffer,
		uint32_t                 const  BufSize)
{
    /* Device instance to work on */
	ADI_CLASS_AD1854   *pDevice = (ADI_CLASS_AD1854 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1854 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* IF (Failed to submit Audio Tx buffer) */
    if (adi_ad1854_SubmitTxBuffer(pDevice->hLoLvlAD1854, pBuffer, BufSize) != ADI_AD1854_SUCCESS)
    {
        /* Return error */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_FAILED);
    }
    /* ELSE (Successfully submitted Audio Tx buffer) */
    else
    {
        /* Return success */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS);
    }
}

/*
 * Submit a RX Buffer
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on
 *  - [in]  pBuffer     Pointer to audio buffer to fill.
 *  - [in]  BufSize     Audio buffer size in bytes.
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 */
static uint32_t adi_pdd_Audio_SubmitRxBuffer(
		ADI_DEV_AUDIO_PDD_HANDLE const  hDevice,
		void                            *pBuffer,
		uint32_t                 const  BufSize)
{
    /* AD1854 can only transmit audio */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Set/Sense Audio device parameters
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  CommandID       Command ID to process
 *  - [in]  Value           Command specific value
 *
 * Return:
 *  TBD
 */
static uint32_t adi_pdd_Audio_Control (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    uint32_t                        CommandID,
    void                            *Value)
{
    /* Return codes */
	uint32_t            Result = (uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS;
	ADI_AD1854_RESULT   eResult = ADI_AD1854_SUCCESS;
    /* Pointer to AD1854 audio class driver instance to work on */
    ADI_CLASS_AD1854   *pDevice = (ADI_CLASS_AD1854 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1854 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* IF (Reset Audio Device) */
    if (CommandID == (uint32_t) ADI_DEV_AUDIO_CMD_RESET)
    {
        /* Issue a hardware reset */
        eResult = adi_ad1854_HwReset (pDevice->hLoLvlAD1854, AD1854_RESET_PORT, AD1854_RESET_PIN);
    }
    /* ELSE IF (Set Audio Input Port Device number) */
    else if (CommandID == (uint32_t) ADI_DEV_AUDIO_CMD_SET_IN_PORT_DEVICE_NUMBER)
    {
        /* Set default SPORT device with AD1854 as clock master */
        eResult = adi_ad1854_SetSportDevice (pDevice->hLoLvlAD1854, (uint32_t) Value, true);
    }
    /* ELSE IF (Enable/Disable Audio Output Data Port) */
    else if (CommandID == (uint32_t) ADI_DEV_AUDIO_CMD_ENABLE_OUT_PORT)
    {
        Result = (uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS;
    }
    /* ELSE (Other commands) */
    else
    {
        /* Function not supported */
        Result = (uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED;
    }

    /* IF (Lower level driver returns error) */
    if (eResult != ADI_AD1854_SUCCESS)
    {
        Result = (uint32_t) ADI_DEV_CLASS_RESULT_FAILED;
    }

    return(Result);
}

/*
 * Enable/Disable audio input (Rx) dataflow
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on
 *  - [in]  bEnable     'true' to enable Rx dataflow, 'false' to disable.
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 */
static uint32_t adi_pdd_AudioIn_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    bool                            bEnable)
{
	/* AD1854 can only transmit audio */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Enable/Disable audio output (Tx) dataflow
 *
 * Parameters:
 *  - [in]  hDevice     Handle to Audio Class Device instance to work on.
 *  - [in]  bEnable     'true' to enable Tx dataflow, 'false' to disable.
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 *
 */
static uint32_t adi_pdd_AudioOut_EnableDataflow (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    bool                            bEnable)
{
    /* Device instance to work on */
    ADI_CLASS_AD1854   *pDevice = (ADI_CLASS_AD1854 *)hDevice;

/* IF (Debug information enabled) */
#if defined (ADI_DEBUG)

    /* IF (AD1854 Handle is invalid) */
    if (ValidateHandle (hDevice) != (uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR)
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_HANDLE_INVALID);
    }

#endif

    /* IF (Failed to enable/disable audio dataflow) */
    if (adi_ad1854_Enable(pDevice->hLoLvlAD1854, bEnable) != ADI_AD1854_SUCCESS)
    {
        /* Return error */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_FAILED);
    }
    /* ELSE (Successfully enabled/disabled audio dataflow) */
    else
    {
        /* Return success */
        return ((uint32_t) ADI_DEV_CLASS_RESULT_SUCCESS);
    }
}

/*
 * Sets Audio Data Word length
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to which the word length applies
 *  - [in]  WordLength      Audio data word length to set
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_NOERROR: Successfully configured Word Length
 *      - ADI_DEV_AUDIO_RESULT_WORD_LENGTH_INVALID: Word Length not supported
 *
 */
static uint32_t adi_pdd_Audio_SetWordLength (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint32_t                        WordLength)
{
    /* IF (Word Length is other than 24-bits) */
    if (WordLength != AD1854_WLEN_BITS)
    {
        /* Return error as word length not supported */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_WORD_LENGTH_INVALID);
    }
    /* ELSE (Word Length supported) */
    else
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
    }
}

/*
 * Sets Audio Channel volume
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to set volume
 *  - [in]  rVolume         Channel Volume range in linear steps
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 *
 */
static uint32_t adi_pdd_Audio_SetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint16_t                        rVolume)
{
    /* AD1854 operating mode is established by external hardware control,
       hence the device registers can't be accessed */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Gets Audio Channel volume
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to set volume
 *  - [in]  prVolume        Location to store Channel Volume
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED: Function not supported
 *
 */
static uint32_t adi_pdd_Audio_GetVolume (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint16_t                        *prVolume)
{
    /* AD1854 operating mode is established by external hardware control,
       hence the device registers can't be accessed */
	return ((uint32_t) ADI_DEV_AUDIO_RESULT_FN_NOT_SUPPORTED);
}

/*
 * Sets Audio Sample rate of selected channel
 *
 * Parameters:
 *  - [in]  hDevice         Handle to Audio Class Device instance to work on
 *  - [in]  eChannelID      Logical Channel ID to set volume
 *  - [in]  SampleRateHz    Sample rate in Hertz
 *  - [in]  bApply          'true' to apply the sample rate to selected channel
 *                          'false' to cache the sample rate with in the driver
 *
 * Return:
 *      - ADI_DEV_AUDIO_RESULT_NOERROR: Successfully configured sample rate
 *      - ADI_DEV_AUDIO_RESULT_SAMPLE_RATE_INVALID: Sample Rate not supported
 *
 */
static uint32_t adi_pdd_Audio_SetSampleRate (
    ADI_DEV_AUDIO_PDD_HANDLE        hDevice,
    ADI_DEV_AUDIO_CHANNEL_ID        eChannelID,
    uint32_t                        SampleRateHz,
    bool                            bApply)
{
    /* IF (Sample Rate is other than 48kHz) */
    if (SampleRateHz != AD1854_SAMPLING_RATE)
    {
        /* Return error as sample rate not supported */
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_SAMPLE_RATE_INVALID);
    }
    /* ELSE (Sample Rate supported) */
    else
    {
        return ((uint32_t) ADI_DEV_AUDIO_RESULT_NOERROR);
    }
}

#ifdef _MISRA_RULES
#pragma diag(pop)
#endif /* _MISRA_RULES */

/*****/
